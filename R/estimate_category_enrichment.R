#' Estimate Genetic Effect Enrichments for Annotation Categories Using Maximum Likelihood
#'
#' This function performs maximum likelihood estimation (MLE) for the probability of causal variants being in each functional annotation category. 
#' The output includes estimated probabilities, standard errors, enrichment fold values, 
#' and profile-likelihood confidence intervals of probabilities (available only for binary functional annotations).
#' 
#' @param bfmap A `data.frame` or `data.table` containing fine-mapping summary statistics generated by BFMAP (forward selection).
#'        Required columns are signal, SNPindex, Pval, normedProb, and SNPname.
#' @param snpinfo A `data.frame` or `data.table` containing SNP functional annotation data, which can be generated using `map_snp_annotation()`.
#' @param cat_prop A `data.frame` or `data.table` containing the proportion of SNPs in each annotation category. 
#'        This can be generated using either `calc_snp_category_prop()` or `calc_category_coverage()`.
#' @param annot A character string specifying the functional annotation column in snpinfo (default: "multi_cat").
#' @param pvalue_threshold A numeric threshold for filtering fine-mapped signals based on p-values (default: 5e-5). 
#'        Only signals with lead SNP p-values below this threshold are included in the analysis.
#' 
#' @return A list containing:
#'   \item{prob_mle}{Maximum likelihood estimates of the probabilities of causal variants being in annotation categories}
#'   \item{prob_cov_matrix}{Covariance matrix of the probability estimates}
#'   \item{loglik}{Log-likelihood value at the maximum}
#'   \item{enrichment_mle}{Maximum likelihood estimates of genetic effect enrichments}
#' 
#' @examples
#' data("dairy_example")
#' mle_result <- estimate_category_enrichment(
#'   dairy_example$bfmap,
#'   dairy_example$snp2annot,
#'   dairy_example$cat_prop,
#'   pvalue_threshold = 5e-5
#' )
#' 
#' @export
#' 
estimate_category_enrichment <- function(bfmap, snpinfo, cat_prop, annot = "multi_cat", pvalue_threshold = 5e-5) {
  # Validate inputs
  pvalue_threshold = as.numeric(pvalue_threshold)
  if(is.na(pvalue_threshold)) {
	stop("'pvalue_threshold' must be numeric.\n", call.=FALSE)
  }
  # Load data
  kept_signals <- bfmap$signal[bfmap$SNPindex == 0 & bfmap$Pval < pvalue_threshold]
  if(length(kept_signals) != length(unique(kept_signals))) {
    stop("Multiple signals have identical signal index.", call.=FALSE)
  }
  bfmap <- bfmap[bfmap$signal %in% kept_signals, ]
  setDT(bfmap)
  nloci = length(kept_signals)

  if (!(annot %in% colnames(snpinfo))) stop(paste(annot, "is not one of the column names in 'snpinfo'"))

  cat_prop[[1]] = factor(cat_prop[[1]], levels=cat_prop[[1]])
  cat_names = levels(cat_prop[[1]])

  snpinfo <- copy(as.data.table(snpinfo))
  snp_colname = colnames(snpinfo)[1]
  snpinfo = copy(snpinfo)[, .SD, .SDcols = c(snp_colname, annot)]
  snpinfo = snpinfo[snpinfo[[snp_colname]] %in% unique(bfmap$SNPname), ]
  snpinfo[is.na(snpinfo[[annot]]),2] = "remaining"
  if(! all(unique(snpinfo[[annot]]) %in% cat_names) ) {
    stop(paste("Some categories in 'snpinfo' are missing in 'cat_prop'.\n"), call.=FALSE)
  }
  snpinfo[[annot]] = factor(snpinfo[[annot]], levels=cat_names)
  cat_cnt = table(snpinfo[[annot]])
  
  levels(snpinfo[[annot]])= c(1:length(cat_names))
  var2cat = new.env(hash=TRUE)
  cats = apply(snpinfo, 1, function(x) var2cat[[x[1]]] = x[annot])
  bfmap[, cat_idx := as.numeric(unlist(sapply(SNPname, function(x) var2cat[[x]])))]

  cat("Number of unique model SNPs in each category:")
  print(cat_cnt)
  if(any(cat_cnt < 50)) {
    cat("\nWarning: Some categories involve too few signal SNPs, which may cause ML estimation problems.\n")
  }
  flush.console()

  if(any(cat_prop[[2]]<=0)) {
    stop(paste("Category proportions in cat_prop must be positive.\n"), call.=FALSE)
  }
  freq = cat_prop[[2]]
  if(sum(freq) != 1) {
    cat("\nSum of proportions in cat_prop is not equal to 1. Scaled to 1.\n")
    freq = freq / sum(freq)
  }

  cat(paste("\nCompleted reading all data files.\n",
      "The ML estimation uses ", nloci, " loci and ", nrow(bfmap)," variants.\n",sep=""))
  flush.console()

  logLL = function(par) {
    par <- c(par, 1-sum(par))   # sum(par) = 1
    if(!any(par<0)) {
      # li = rep(0, nloci)
      # for(i in c(1:nloci)) {
      #   d = bfmap[bfmap$signal==kept_signals[i],]
      #   pp = par[d$cat_idx]
      #   qp = freq[d$cat_idx]
      #   li[i] = sum(d[[pcol]]*pp/qp)
      # }
      ret = bfmap[, .(li = sum(normedProb * par[cat_idx] / freq[cat_idx])), by = signal][, sum(log(li))]
      return(ret)
    } else return(-100000)
  }

  par = freq[1:(length(freq)-1)]
  npars = length(par)
  result = NA

  eps = 1e-12
  if(npars == 1) {
    result <- optim(par, logLL, method="Brent",
            hessian=T,
            lower=rep(eps, npars),
            upper=rep(1-eps, npars),
            control=list(fnscale=-1))
  } else {
    # First try optim
    result <- try(optim(par, logLL, method="L-BFGS-B",
              hessian=T,
              lower=rep(eps, npars),
              upper=rep(1-eps, npars),
              control=list(fnscale=-1)), silent=TRUE)
    # If optim fails, try constrOptim
    if(inherits(result, "try-error") || result$convergence != 0 || any(result$par < 1e-3)) {
      cat("Initial optimization failed. Trying constrOptim...\n")
      flush.console()

      ui = rbind(diag(npars), rep(-1, npars))
      ci = c(rep(eps, npars), -1)
      result_constr <- constrOptim(theta=par, f=logLL, grad=NULL,
                  ui=ui, ci=ci,
                  control=list(fnscale=-1))
      # Add Hessian to result_constr before assigning to result
      result_constr$hessian <- try(optimHess(result_constr$par, logLL))
      result <- result_constr
      cat("constrOptim completed.\n")
      flush.console()
    }
  }
  cat("Completed MLE.\n")

  covar_mle = solve(-result$hessian)
  cat("Calculated SE with Hessian.\n")
  flush.console()

  # Profile likelihood method for SE
  profile_se <- function(mle, delta = seq(-0.1, 0.1, length=41)) {
    # Calculate profile likelihood around MLE
    profile_points <- mle + delta
    profile_points <- profile_points[profile_points>0 & profile_points<1]
    profile_values <- sapply(profile_points, logLL)

    # Maximum likelihood at MLE
    max_ll <- max(profile_values)

    # Find points where log-likelihood drops by 1.92
    # (approximately 95% CI region)
    cutoff <- max_ll - 1.92
    valid_points <- profile_points[profile_values >= cutoff]

    # SE estimate from the range
    se <- diff(range(valid_points))/3.84

    # Return full information for diagnostics
    return(list(
      se = se,
      profile_points = profile_points,
      profile_values = profile_values,
      cutoff = cutoff,
      ci = range(valid_points)
    ))
  }

  mle <- result$par
  prob_mle = copy(cat_prop)
  setDT(prob_mle)
  prob_mle[, paste0("V", 3:7) := NA_real_]
  prob_mle[[3]]=c(mle, 1-sum(mle))

  prob_cov_matrix <- rbind(
    cbind(covar_mle, -covar_mle %*% rep(1, nrow(covar_mle))),
    c(-covar_mle %*% rep(1, nrow(covar_mle)), sum(covar_mle))
  )
  prob_mle[[4]] = sqrt(diag(prob_cov_matrix))
  if(npars == 1) {
    profileLL_result <- profile_se(mle)
    cat("Completed profile likelihood (used only for binary annotations).\n")
    prob_mle[[5]] = rep(profileLL_result$se, 2)
    prob_mle[1, (6:7) := as.list(profileLL_result$ci)]
    prob_mle[2, (6:7) := as.list(rev(1-profileLL_result$ci))]
  }
  colnames(prob_mle)[2:7] = c("q", "p_MLE", "Hessian_SE", "profile_SE", "profile_95lower", "profile_95upper")
  colnames(prob_cov_matrix) = levels(cat_prop[[1]])

  enrichment_mle = prob_mle[,1:4]
  colnames(enrichment_mle) =c("category","enrichment","SE","p")
  enrichment_mle[,2] = prob_mle$p_MLE / prob_mle$q
  enrichment_mle[,3] = prob_mle$Hessian_SE / prob_mle$q
  enrichment_mle[,4] = pnorm( (enrichment_mle[[2]]-1)/enrichment_mle[[3]], lower.tail = F)

  output <- list()
  output[["prob_mle"]] = prob_mle
  output[["prob_cov_matrix"]] = prob_cov_matrix
  output[["loglik"]] = result$value
  output[["convergence"]] = result$convergence
  output[["counts"]] = cat_cnt
  output[["enrichment_mle"]] = enrichment_mle
  return(output)
}
