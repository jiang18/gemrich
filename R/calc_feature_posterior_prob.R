#' Calculate Genomic-Feature Posterior Probabilities from Fine-Mapping
#'
#' This function calculates the posterior probability of genomic features containing causal variants
#' by integrating fine-mapping results with genomic feature annotations. For forward selection, it uses
#' SNP-level probabilities. For SSS, it uses model-level probabilities.
#'
#' @param model A `data.frame` or `data.table` containing fine-mapping summary statistics generated by BFMAP.
#'        For forward selection: Required columns are signal, SNPindex, Chr, Pos, Pval, and normedProb.
#'        For SSS: Required columns are variant IDs (first n-2 columns) and probabilities (the last column).
#' @param feature A `data.frame` or `data.table` containing genomic feature coordinates and identifiers.
#'        Required columns are chr, start, end, and feature_id.
#' @param extension A numeric value specifying the number of base pairs to extend upstream and downstream of each feature (default: 3000).
#' @param pvalue_threshold A numeric threshold for filtering fine-mapped signals based on p-values (default: 5e-5). 
#'        Only used for forward selection format.
#' @param input_type Character string specifying the input format: "forward_selection" (default) or "sss".
#' @param pip For SSS format: A `data.table` with variant-level PIP data.
#'        Required columns are SNPname, Chr, and Pos.
#' 
#' @return A `data.table` containing features and their posterior probabilities of containing causal variants.
#'
#' @examples
#' data("dairy_example")
#' # Forward selection
#' feature_probs = calc_feature_posterior_prob(
#'   dairy_example$bfmap, 
#'   dairy_example$feature, 
#'   extension = 1000, 
#'   pvalue_threshold = 5e-7
#' )
#' # SSS
#' # feature_probs_sss = calc_feature_posterior_prob(
#' #   sss_model_data,
#' #   feature, 
#' #   extension = 3000,
#' #   input_type = "sss",
#' #   pip = sss_pip_data
#' # )
#' 
#' @export
#'
calc_feature_posterior_prob <- function(model, feature, extension = 3000, pvalue_threshold = 5e-5, 
                                   input_type = "forward_selection", pip = NULL) {
  
  # Handle SSS format
  if (input_type == "sss") {
    return(calc_feature_posterior_prob_sss(model, feature, extension, pip))
  }
  
  # Forward selection code (unchanged from original)
  # For forward selection, model is actually bfmap
  bfmap <- model
  setDT(bfmap)
  setDT(feature)
  
  bfmap[, Chr := as.character(Chr)]
  message("Starting calculations..."); flush.console()
  
  # Column checks
  required_bfmap <- c("signal", "SNPindex", "Chr", "Pos", "Pval", "normedProb")
  required_feature <- c("chr", "start", "end", "feature_id")
  
  if (!all(required_bfmap %in% colnames(bfmap))) {
    stop("Missing bfmap columns: ", paste(setdiff(required_bfmap, colnames(bfmap)), collapse=", "))
  }
  if (!all(required_feature %in% colnames(feature))) {
    stop("Missing feature columns: ", paste(setdiff(required_feature, colnames(feature)), collapse=", "))
  }
  
  # Process reverse strand
  message("Processing feature coordinates..."); flush.console()
  reverse_idx <- feature[, which(end < start)]
  if (length(reverse_idx) > 0) {
    message(sprintf("Found %d reverse strand features", length(reverse_idx))); flush.console()
    feature[reverse_idx, c("start", "end") := .(end, start)]
  }
  
  # Filter signals and extend boundaries
  message("Filtering signals..."); flush.console()
  sig_signals <- bfmap[SNPindex == 0 & Pval <= pvalue_threshold, unique(signal)]
  message(sprintf("Found %d significant signals", length(sig_signals))); flush.console()
  
  bfmap_filtered <- bfmap[signal %in% sig_signals]
  feature[, `:=`(
    start_ext = start - extension,
    end_ext = end + extension
  )]
  
  # Calculate overlaps and sum probabilities
  message("Calculating overlaps..."); flush.console()
  results <- bfmap_filtered[feature, on = .(Chr = chr), 
    allow.cartesian = TRUE, nomatch = 0][
      Pos >= start_ext & Pos <= end_ext,
      .(summed_prob = sum(normedProb)), 
      by = .(feature_id, signal)
    ]
  
  # Add feature information and lead p-values
  results <- feature[results, on = "feature_id"]
  lead_pvals <- bfmap_filtered[SNPindex == 0, .(signal, lead_pvalue = Pval)]
  results <- lead_pvals[results, on = "signal"]
  
  message(sprintf("Found %d feature-signal pairs", nrow(results))); flush.console()

  setcolorder(results, c("feature_id", "chr", "start", "end", "signal", "summed_prob", "lead_pvalue", "start_ext", "end_ext"))
  setorder(results, -summed_prob, chr, start, signal)
  return(results[])
}

# SSS feature posterior probability calculation
calc_feature_posterior_prob_sss <- function(model, feature, extension = 3000, pip) {
  
  setDT(model); setDT(feature); setDT(pip)
  
  message("Starting SSS feature PIP calculations..."); flush.console()
  
  # Validate inputs
  if(is.null(pip)) {
    stop("pip is required for SSS format")
  }
  
  # Check required columns in pip
  required_pip_cols <- c("SNPname", "Chr", "Pos")
  if(!all(required_pip_cols %in% names(pip))) {
    stop(paste("pip must contain columns:", paste(required_pip_cols, collapse = ", ")))
  }
  
  if(!all(c("chr", "start", "end", "feature_id") %in% names(feature))) {
    stop("feature must contain columns: chr, start, end, feature_id")
  }
  
  # Process feature coordinates
  message("Processing feature coordinates..."); flush.console()
  feature[, chr := as.character(chr)]
  pip[, Chr := as.character(Chr)]
  
  # Handle reverse strand features
  feature[end < start, c("start", "end") := .(end, start)]
  
  # Add extension to feature boundaries
  feature[, `:=`(start_ext = start - extension, end_ext = end + extension)]
  
  message("Calculating feature PIPs using model-based approach..."); flush.console()
  
  # Efficient approach: Use data.table join to find feature-variant overlaps
  feature_variant_overlaps <- pip[feature, on = .(Chr = chr), 
    allow.cartesian = TRUE, nomatch = 0][
      Pos >= start_ext & Pos <= end_ext,
      .(feature_id, SNPname)
    ]
  
  # Group variants by feature
  feature_variants_list <- feature_variant_overlaps[, .(feature_variants = list(SNPname)), by = feature_id]

  # Initialize results
  output <- feature[feature_id %in% feature_variants_list$feature_id, .(feature_id, chr, start, end, start_ext, end_ext)]

  # Calculate feature PIPs for features with variants
  for(i in seq_len(nrow(feature_variants_list))) {
    target_id <- feature_variants_list$feature_id[i]
    feature_variants <- feature_variants_list$feature_variants[[i]]

    # Calculate feature PIP using efficient matrix approach
    nSNPcols <- ncol(model) - 2  # Variant columns (excluding locus and probability)
    
    if (nSNPcols > 0 && length(feature_variants) > 0) {
      # Create matrix of whether each model SNP is in feature_variants
      in_snp_mat <- sapply(1:nSNPcols, function(j) model[[j]] %in% feature_variants)
      
      # Handle case where sapply returns a vector (single model)
      if (is.vector(in_snp_mat)) {
        in_snp_mat <- matrix(in_snp_mat, ncol = 1)
      }
      
      target_pip <- sum(model[rowSums(in_snp_mat) > 0, ncol(model), with = FALSE][[1]])
    } else {
      target_pip <- 0
    }
    # Update output
    output[feature_id == target_id, feature_pip := target_pip]
  }
  
  # Filter and sort results
  setorder(output, -feature_pip)
  
  message(sprintf("Calculated PIPs for %d features", nrow(output))); flush.console()
  
  setcolorder(output, c("feature_id", "chr", "start", "end", "feature_pip", "start_ext", "end_ext"))
  return(output[])
}
